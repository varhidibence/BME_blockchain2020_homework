module BikeSharing where
import DA.Time
import DA.Optional
import DA.List (delete)
{-
-}
type OrgKey = (Party,Text)
type BikeUsageRightKey = (Party,Text,Party) -- orgOwner, orgName, holder
type AccountKey = (Party,Text,Party) -- orgOwner,orgName,accountOwner

{-
Function, returns whether a party is member of a bikeOrg
@param
    party: Party - this party will be tested
    bikeOrgName: Text - name of the bikeOrg
    bikeOrgOwner: Party - owner of the bikeOrg
@return
    Update Bool
@Usage
    isBikeOwner <- partyIsBikeOwner [parameters]
-}
partyIsBikeOwner: Party->Text->Party->Update Bool
partyIsBikeOwner party bikeOrgName bikeOrgOwner = do
    (orgId,org) <- fetchByKey @BikeOrg (bikeOrgOwner,bikeOrgName)
    if  party `elem` org.members then
        return True
    else
        return False
{-
Function, a bit complex..
Its responsibility to handle the necessary transactions during transfering a BikeUsageRight (instant or not)

@param
    accountCid: BikeAccount - accountCid to transfer from
    bikeOwner: Party
    oldHolder: Party
    newHolder: Party
    price: Decimal
    bikeUsageRight: BikeUsageRight

@return
    Update (Decimal,ContractId BikeAccount,ContractId BikeUsageRight,Optional (ContractId TokenTransfer))

@usage
    (transferedToContract,bikeAccountCid,bikeUsageRightCid,optionalTokenTransfer) <- handleBikeUsageTransfer [parameters]
-}
handleBikeUsageTransfer: ContractId BikeAccount->Party->Party->Party->Decimal->BikeUsageRight->Update (Decimal,ContractId BikeAccount,ContractId BikeUsageRight,Optional (ContractId TokenTransfer))
handleBikeUsageTransfer accountCid bikeOwner oldHolder newHolder price bikeUsageRight = do
                        account <- fetch accountCid
                        time <- getTime
                        let onehour = hours 1
                        newHolderIsOwner <- partyIsBikeOwner newHolder bikeUsageRight.orgName bikeUsageRight.orgOwner
                        assertMsg "Can not sell to bike owner" (newHolderIsOwner && price == 0.0 || not newHolderIsOwner)
                        oldHolderIsOwner <- partyIsBikeOwner oldHolder bikeUsageRight.orgName bikeUsageRight.orgOwner
                        assertMsg "Bike owner can not sell" (oldHolderIsOwner && price == 0.0 || not oldHolderIsOwner)
                        if newHolderIsOwner then --
                            do
                                bikeUsageRightCid <- create bikeUsageRight with
                                            holder = newHolder
                                            bikeCoin = bikeUsageRight.bikeCoin
                                            from = time
                                            to = addRelTime time onehour
                                            locked = True
                                return (0.0,accountCid,bikeUsageRightCid,None)
                        else
                            if oldHolderIsOwner then -- transfer the fee to the owner (no pay to contract)
                                do
                                    assertMsg "Not enough coin in the account" (account.balance >= bikeUsageRight.fee)
                                    (tokenTransferCid,bikeAccountCid) <- exercise accountCid Transfer with
                                        tokens = bikeUsageRight.fee
                                        to = oldHolder
                                    let transfered = 0.0
                                    bikeUsageRightCid <- create bikeUsageRight with
                                        holder = newHolder
                                        bikeCoin = bikeUsageRight.bikeCoin + transfered
                                        from = time
                                        to = addRelTime time onehour
                                        locked = True
                                    return (transfered,bikeAccountCid,bikeUsageRightCid,Some tokenTransferCid)
                            else
                                if price == 0.0
                                    then -- transfer the fee only to the contract
                                        do
                                            assertMsg "Not enough coin in the account" (account.balance >= bikeUsageRight.fee)
                                            bikeAccountCid <- exercise accountCid TransferToContract with
                                                tokens = bikeUsageRight.fee
                                            bikeUsageRightCid <- create bikeUsageRight with
                                                holder = newHolder
                                                bikeCoin = bikeUsageRight.bikeCoin + bikeUsageRight.fee
                                                from = time
                                                to = addRelTime time onehour
                                                locked = True
                                            return (bikeUsageRight.fee,bikeAccountCid,bikeUsageRightCid,None)
                                    else -- transfer to the oldHolder the price and the fee to the contract
                                        do
                                        assertMsg "Not enough coin in the account" (account.balance >= bikeUsageRight.fee+price)
                                        (tokenTransferCid,bikeAccountCid) <- exercise accountCid Transfer with
                                            tokens = price
                                            to = oldHolder
                                        bikeAccountCid <- exercise bikeAccountCid TransferToContract with
                                            tokens = bikeUsageRight.fee
                                        bikeUsageRightCid <- create bikeUsageRight with
                                            holder = newHolder
                                            bikeCoin = bikeUsageRight.bikeCoin + bikeUsageRight.fee
                                            from = time
                                            to = addRelTime time onehour
                                            locked = True
                                        return (bikeUsageRight.fee,bikeAccountCid,bikeUsageRightCid,Some tokenTransferCid)

template BikeOrg with
        owner: Party
        members: [Party]
        observers: [Party]
        name: Text
        bikeIds: [Text]
    where 
        signatory owner
        observer observers,members
        key ( owner,name ): OrgKey
        maintainer key._1

        controller owner can
            AddMember : ContractId BikeOrg with 
                    newMember : Party
                do 
                    create this with 
                        members = newMember :: members
                        observers = newMember :: observers
            
            AddObserver: ContractId BikeOrg with
                    newObserver: Party
                do create this with
                    observers = newObserver :: observers

            CreateBikeUsageRight: (ContractId BikeUsageRight,ContractId BikeOrg) with
                    bikeId: Text
                    fee: Decimal
                do
                    assertMsg "bikeId needs to be unique" (bikeId `notElem` bikeIds)
                    time <- getTime
                    bikeUsageRightCid <- create BikeUsageRight with
                        owner = this.owner
                        bikeId
                        locked = False
                        holder = this.owner
                        from = time
                        to = time
                        fee
                        bikeCoin = 0.0
                        approvedBy = []
                        orgName = name
                        orgOwner = this.owner
                        observers = this.observers ++ this.members
                    bikeOrgId <- create this with
                        bikeIds = bikeId :: bikeIds
                    return (bikeUsageRightCid,bikeOrgId)

        nonconsuming choice Offer : ContractId BikeOffering with
                party : Party
                fee: Decimal
                bikeId: Text
            controller party
                do
                    bikeAccountCid <- lookupByKey @BikeAccount (this.owner,this.name,party)
                    assertMsg "Party needs to have a BikeAccount" (bikeAccountCid /= None)
                    assertMsg "bikeId needs to be unique" (bikeId `notElem`  bikeIds)
                    assertMsg "fee cannot be negative" (fee >= 0.0)
                    create BikeOffering with
                        orgName = this.name
                        fee = fee
                        owner = party
                        approvedBy = []
                        bikeOrgOwner = this.owner
                        bikeOwners = this.members
                        bikeId

template BikeAccountRegistration with
        party: Party
        username: Text
        orgName: Text
        orgOwner: Party
    where
        signatory party
        observer orgOwner

        choice AcceptRegistration: (ContractId BikeAccount,ContractId BikeOrg) with
                approver : Party
            controller approver
                do
                    (orgCid,org) <- fetchByKey @BikeOrg (orgOwner,orgName)
                    assertMsg "Only org owner can approve" (approver == org.owner)
                    bikeAccountCid <- create BikeAccount with
                        owner = party
                        balance = 2000.0
                        name = username
                        issuer = org.owner
                        isBikeOwner = False
                        bikeOrgName = org.name
                    archive orgCid
                    bikeOrgCid <- create org with
                        observers = party::org.observers
                    return (bikeAccountCid,bikeOrgCid)

template BikeAccount with
        owner: Party
        balance: Decimal
        name: Text
        issuer: Party -- BikeOrgOwner
        isBikeOwner: Bool -- not used
        bikeOrgName: Text
    where
        signatory issuer
        observer owner
        ensure balance >= 0.0

        key (issuer,bikeOrgName,owner): AccountKey
        maintainer key._1

        controller owner can
            Transfer: (ContractId TokenTransfer,ContractId BikeAccount) with
                    tokens: Decimal
                    to: Party
                do 
                    assertMsg "Tokens need to be less or equal then balance" (balance >=tokens)
                    -- toAccount <- fetch to
                    bikeAccountCid <- create this with
                        balance = balance - tokens
                    tokenTransferCid <- create TokenTransfer with 
                        tokens = tokens
                        fromAccount = self
                        issuer = this.issuer
                        from = owner
                        to = to
                    return (tokenTransferCid,bikeAccountCid)
            TransferToContract: ContractId BikeAccount with
                    tokens: Decimal
                do 
                    assertMsg "Tokens need to be less or equal then balance" (balance >=tokens)
                    create this with
                        balance = balance - tokens
        controller issuer,owner can
            UpdateAccount: ContractId BikeAccount do
                (orgId,org) <- fetchByKey @BikeOrg (issuer,bikeOrgName)
                let isBikeOwner = if elem owner org.members then True else False
                create this with
                    isBikeOwner = isBikeOwner

template TokenTransfer with
        tokens: Decimal
        fromAccount: ContractId BikeAccount
        issuer: Party
        to: Party
        from: Party
    where
        signatory from,issuer

        controller to can
            Accept: ContractId BikeAccount with
                    accountCid: ContractId BikeAccount
                do
                    account <- fetch accountCid
                    archive accountCid
                    create account with
                        balance = account.balance + tokens

template BikeOffering with
        owner: Party
        fee: Decimal
        orgName: Text
        bikeId: Text
        approvedBy: [Party]
        bikeOrgOwner: Party
        bikeOwners: [Party]
    where
        signatory owner,approvedBy,bikeOrgOwner
        observer bikeOwners

        choice Approve: ContractId BikeOffering with
                approver: Party
            controller approver
                do
                    (orgId,org) <- fetchByKey @BikeOrg (bikeOrgOwner,orgName)
                    -- assertMsg "BikeOrg needs to be the same as it was before" (org.name == approversOrg.name && org.owner == approversOrg.owner)
                    assertMsg "Approvers needs to be a member of the org" (approver `elem` org.members)
                    assertMsg "Approver can not be the owner" (approver /= owner)
                    -- assertMsg "Approver needs to be the member of the committee" (approver `elem` org.members)
                    assertMsg "Already approved by this party"  (approver `notElem` approvedBy)
                    assertMsg "Try final approve" (length approvedBy /= 2)
                    create this with
                        approvedBy = approver :: approvedBy
                        bikeOwners = org.members
        
        choice FinalApprove: (ContractId BikeUsageRight,ContractId BikeOrg) with
                approver: Party
            controller approver
                do
                    (orgId,org) <- fetchByKey @BikeOrg (bikeOrgOwner,orgName)
                    -- assertMsg "BikeOrg needs to be the same as it was before" (org.name == approversOrg.name && org.owner == approversOrg.owner)
                    assertMsg "Approvers needs to be a member of the org" (elem approver org.members)
                    assertMsg "Approver can not be the owner" (approver /= owner)
                    -- assertMsg "Approver needs to be the member of the committee" (approver `elem` org.members)
                    assertMsg "Already approved by this party"  (approver `notElem` approvedBy)
                    assertMsg "Needs to have three approvers" (length approvedBy == 2)
                    archive orgId
                    orgId <- create org with
                        members = owner :: org.members
                        bikeIds = bikeId :: org.bikeIds
                    
                    time <- getTime
                    bikeId <- create BikeUsageRight with
                        owner
                        bikeId
                        locked = False
                        holder = owner
                        from = time
                        to = time
                        fee
                        bikeCoin = 0.0
                        approvedBy = approver::approvedBy
                        orgName = org.name
                        orgOwner = bikeOrgOwner
                        observers = org.observers ++ org.members
                    return (bikeId,orgId)
                    
                    
template BikeUsageRight with
        owner: Party
        bikeId: Text
        locked: Bool
        holder: Party
        from: Time  -- rename to start?
        to: Time    -- rename to end?
        fee: Decimal
        bikeCoin: Decimal
        approvedBy: [Party]
        orgName: Text
        orgOwner: Party
        observers: [Party]
    where 
        signatory owner,holder,orgOwner
        observer observers
        -- one holder can only have one locked bikeUsageRight
        -- this assumes unique bikeIds!
        -- during the registration of the bike, BikeOrg will ensure the unique BikeId-s!!
        key (orgOwner,if locked then "" else bikeId,holder): BikeUsageRightKey
        maintainer key._1
    
        choice TransferBikeUsage : ContractId BikeUsageTransfer with
                party : Party
                price : Decimal
            controller holder
                do
                    -- assertMsg "Only the holder" (party == holder)
                    create BikeUsageTransfer with
                        oldHolder = holder
                        newHolder = party
                        issuer = orgOwner
                        price
                        bikeUsageRight = this
                        bikeOwner = owner
                        
        choice InstantTransfer : (ContractId BikeUsageRight,ContractId BikeAccount,Optional (ContractId TokenTransfer)) with
                party : Party
                accountCid : ContractId BikeAccount
            controller party
                do
                    let threehours = hours 3
                    let endPlus3Hours = addRelTime to threehours
                    time <- getTime -- az aktualis ido kene, amikor a choice lefut
                    assertMsg "cannot transfer because last usage was in 3 hours or it is not free" ((time >= endPlus3Hours && locked) || not locked)
                    -- InstantTransfer
                    (transferedToContract,bikeAccountCid,bikeUsageRightCid,optionalTokenTransfer) <- handleBikeUsageTransfer
                        accountCid
                        owner
                        holder
                        party
                        0.0
                        this
                    return (bikeUsageRightCid,bikeAccountCid,optionalTokenTransfer)

        nonconsuming choice MakeUsageRequest : ContractId BikeUsageRequest with
                requester : Party
                requesteraccountId : ContractId BikeAccount
                price : Decimal
            controller requester
                do
                    assertMsg "current holder of the usage could not make request on own" (requester /= holder) 
                    create BikeUsageRequest with
                        bikeOwner = owner
                        accepter = holder
                        requester = requester
                        requesterAccountId = requesteraccountId
                        issuer = orgOwner
                        price
                        bikeUsageRightCid = self
        choice Lock : (ContractId BikeUsageRight,ContractId ClosedBikeUsage) with
            controller holder
                do 
                    -- lock the BikeUsageRight, create a ClosedBikeUsage
                    bikeUsageRightCid <- create this with
                        bikeCoin = 0.0
                        locked = False
                        holder = owner
                    (orgId,org) <- fetchByKey @BikeOrg (orgOwner,orgName)
                    closedBikeUsageCid <- create ClosedBikeUsage with
                        bikUsageRightCid = bikeUsageRightCid
                        bikeCoin = this.bikeCoin
                        bikeOwners = org.members
                        bikeOrgOwner = orgOwner
                        bikeOrgName = orgName
                        transferOut = 0
                        noTransferOut = 0
                        notVotedYet = org.members
                        votersForDivide = []
                        numberOfVotedForDivide = 0
                        votersForNotDivide = []
                        numberOfVotedForNotDivide = 0
                    return (bikeUsageRightCid,closedBikeUsageCid)
                    
                    

        --for each additional hour of unlocking, they must pay some fee into the contract      
        choice ProLongForAnHour : (ContractId BikeUsageRight,ContractId BikeAccount) with
                accountCid : ContractId BikeAccount
            controller holder
                do
                    time <- getTime
                    let onehour = hours 1
                    holderIsOwner <- partyIsBikeOwner holder orgName orgOwner
                    -- pay only if not owner
                    (transferedToContract,bikeAccountCid) <- do
                        if not holderIsOwner then
                            do
                                bikeAccountCid<-exercise accountCid TransferToContract with
                                    tokens = fee
                                return (fee,bikeAccountCid)
                        else
                            do
                                return (0.0,accountCid)
                    bikeUsageRightCid<-create this with
                        bikeCoin = bikeCoin + transferedToContract
                        --from = time -- sztem ezt nem kell update-elni
                        to = addRelTime to onehour -- a to értéket növelni kellene nem felülírni sztem
                    return (bikeUsageRightCid,bikeAccountCid)

template BikeUsageTransfer with
        bikeOwner: Party
        oldHolder: Party
        newHolder: Party
        issuer: Party
        price: Decimal
        bikeUsageRight: BikeUsageRight
    where
        signatory issuer,bikeOwner,oldHolder

        controller newHolder can
            AcceptBikeUsageTransfer : (ContractId BikeUsageRight,ContractId BikeAccount,Optional (ContractId TokenTransfer)) with
                    accountCid: ContractId BikeAccount
                do
                    account <- fetch accountCid
                    time <- getTime
                    let onehour = hours 1
                    (transferedToContract,bikeAccountCid,bikeUsageRightCid,optionalTokenTransfer) <- handleBikeUsageTransfer
                        accountCid
                        bikeOwner
                        oldHolder
                        newHolder
                        price
                        bikeUsageRight 
                    return (bikeUsageRightCid,bikeAccountCid,optionalTokenTransfer)

template BikeUsageRequest with
        bikeOwner : Party
        accepter : Party
        requester : Party
        requesterAccountId : ContractId BikeAccount
        issuer : Party --ennek mi is a szerepe? -- hogy itt feltétlen szükséges e abban nem vagyok biztos, magán a bikeusageright-on kell, mert ő a legfőbb kibocsátó, emiatt nem lehet hamisítani a UsageRight-ot
        price : Decimal
        bikeUsageRightCid : ContractId BikeUsageRight
    where
        signatory issuer,requester --bikeOwnernek ala kell irnia? -- sztem nem
        observer accepter

        controller accepter can
            AcceptRequest : ContractId BikeUsageTransfer
                    --with accountCid: ContractId BikeAccount
                do
                    --account <- fetch accountCid
                    bikeUsageRight <- fetch bikeUsageRightCid
                    time <- getTime
                    let onehour = hours 1 
                    archive bikeUsageRightCid
                    create BikeUsageTransfer with
                        oldHolder = accepter
                        newHolder = requester
                        issuer = issuer
                        price
                        bikeUsageRight = bikeUsageRight
                        bikeOwner = bikeUsageRight.owner                         

template ClosedBikeUsage -- TODO ha nem tag hozza letre, akkor is latja (gondolom mert a Lock-nal o hozza letre)
    with
        bikUsageRightCid: ContractId BikeUsageRight
        bikeCoin: Decimal
        bikeOwners: [Party]
        bikeOrgOwner:Party
        bikeOrgName: Text
        transferOut: Int
        noTransferOut: Int
        notVotedYet : [Party]
        votersForDivide: [Party]
        numberOfVotedForDivide: Int
        votersForNotDivide: [Party]
        numberOfVotedForNotDivide: Int
    where
        signatory bikeOrgOwner
        observer bikeOwners

        choice VoteForDivide : ContractId ClosedBikeUsage with
           party : Party
         controller party
            do
                assertMsg "Only bike owners can vote" (party `elem` bikeOwners)
                assertMsg "This owner has already voted" (party `notElem` votersForDivide)
                assertMsg "This owner has already voted" (party `notElem` votersForNotDivide)
                let voters2 =  delete party notVotedYet
                let incrementedVoted = numberOfVotedForDivide + 1
                create this with 
                    votersForDivide = party :: votersForDivide
                    notVotedYet = voters2
                    numberOfVotedForDivide = incrementedVoted

        choice VoteForNotDivide : ContractId ClosedBikeUsage with
           party : Party
         controller party
            do
                assertMsg "Only bike owners can vote" (party `elem` bikeOwners)
                assertMsg "This owner has already voted" (party `notElem` votersForDivide)
                assertMsg "This owner has already voted" (party `notElem` votersForNotDivide)
                let voters2 =  delete party notVotedYet
                let incrementedVoted = numberOfVotedForNotDivide + 1
                create this with 
                    votersForNotDivide = party :: votersForNotDivide
                    notVotedYet = voters2
                    numberOfVotedForNotDivide = incrementedVoted

        choice AssessVoting : ContractId BikeUsageRight with
         controller bikeOrgOwner
            do
                assertMsg "Someone has not already voted" (notVotedYet == [])
                -- if voters for divide in major, 
                --divide the coins, and restore the BikeUsageRight with locked false
                if (numberOfVotedForDivide > numberOfVotedForNotDivide)
                    then
                        do
                            -- TODO : divide and transfer the proper bikecoins
                            bikeUsageRight <- fetch bikUsageRightCid
                            archive bikUsageRightCid
                            create BikeUsageRight with
                                owner = bikeUsageRight.owner
                                bikeId = bikeUsageRight.bikeId
                                locked = False
                                holder = bikeUsageRight.holder
                                from = bikeUsageRight.from
                                to = bikeUsageRight.to
                                fee = bikeUsageRight.fee
                                bikeCoin = bikeUsageRight.bikeCoin
                                approvedBy = bikeUsageRight.approvedBy
                                orgName = bikeUsageRight.orgName
                                orgOwner = bikeUsageRight.orgOwner
                                observers = bikeUsageRight.observers
                            
                    -- voters for not divide is major, or equal
                    -- not transfer out the coins, restore the usage right with the coins       
                    else
                        do
                                bikeUsageRight <- fetch bikUsageRightCid
                                archive bikUsageRightCid
                                create BikeUsageRight with
                                    owner = bikeUsageRight.owner
                                    bikeId = bikeUsageRight.bikeId
                                    locked = False
                                    holder = bikeUsageRight.holder
                                    from = bikeUsageRight.from
                                    to = bikeUsageRight.to
                                    fee = bikeUsageRight.fee
                                    bikeCoin = this.bikeCoin
                                    approvedBy = bikeUsageRight.approvedBy
                                    orgName = bikeUsageRight.orgName
                                    orgOwner = bikeUsageRight.orgOwner
                                    observers = bikeUsageRight.observers
                                


                    
                
              
    
test_bikeAccount_registration = scenario 
    do
        bme <- getParty "BME Bike sharing"
        bowner1 <- getParty "Bike Owner1"
        newUser <- getParty "Not BikeOwner1"

        bmeOrgCid <- submit bme do
            create BikeOrg with
                owner = bme
                members = [bowner1,bme]
                observers = []
                name = "BME Bike Sharing org"
                bikeIds = []

        registrationCid <- submit newUser do
            create BikeAccountRegistration with
                party = newUser
                username = "New User"
                orgName = "BME Bike Sharing org"
                orgOwner = bme

        submit bme do
            exercise registrationCid AcceptRegistration with
                approver = bme


        assertMsg "Hello" (True)
test_the_bike_token = scenario
    do
        bme <- getParty "CommitteeOwner"
        bikeOwner1 <- getParty "BikeOwner1"
        bikeOwner2 <- getParty "BikeOwner2"
        bikeOwner3 <- getParty "BikeOwner3"

        -- Create a committee this collects the bike owners
        bikeOrg <- submit bme do
            create BikeOrg with
                owner = bme
                members = [bme]
                observers = [bme]
                name = "BME Bikeorg"
                bikeIds = []

        (bikeOwner1AccountCid,bikeOwner2AccountCid) <- submit bme do
            bikeOwner1AccountCid <- create BikeAccount with
                owner = bikeOwner1
                balance = 500.0
                name = "BikeWallet"
                issuer = bme
                isBikeOwner = False
                bikeOrgName = "BME Bikeorg"
            bikeOwner2AccountCid <- create BikeAccount with
                owner = bikeOwner2
                balance = 500.0
                name = "BikeWallet"
                issuer = bme
                isBikeOwner = False
                bikeOrgName = "BME Bikeorg"
            return (bikeOwner1AccountCid,bikeOwner2AccountCid)

        (tokenTransferCid,bikeAccountCid) <- submit bikeOwner1 do
            exercise bikeOwner1AccountCid Transfer with
                to = bikeOwner2
                tokens = 200.0

        submit bikeOwner2 do
            exercise tokenTransferCid Accept with
                accountCid = bikeOwner2AccountCid

        assertMsg "Hello" (True)

{-- STRUCTURED TEST SCENARIOS--} 
create_and_approve_bike_offering = scenario 
    do
        -- create committee members
        committeeOwner <- getParty "CommitteeOwner"
        bikeOwner1 <- getParty "BikeOwner1"
        bikeOwner2 <- getParty "BikeOwner2"
        bikeOwner3 <- getParty "BikeOwner3"

        -- Create a committee this collects the bike owners
        bikeOrg <- submit committeeOwner do
            create BikeOrg with
                owner = committeeOwner
                members = [committeeOwner]
                observers = [committeeOwner]
                name = "BME Bikeorg"
                bikeIds = []
        -- Create a new party who is an offerer
        offerer <- getParty "BikeOfferer"

        -- register to the bikeOrg
        registrationCid <- submit offerer do
            create BikeAccountRegistration with
                party = offerer
                username = "Bike Offerer"
                orgName = "BME Bikeorg"
                orgOwner = committeeOwner
        
        (bikeAccountCid,bikeOrgId)<-submit committeeOwner do
            exercise registrationCid AcceptRegistration with
                approver = committeeOwner

        -- add members to the committee
        bikeOrgId <- submit committeeOwner do
            exercise bikeOrgId AddMember with
                newMember = bikeOwner1
        bikeOrgId <- submit committeeOwner do
            exercise bikeOrgId AddMember with
                newMember = bikeOwner2
        
        -- create a bike offering
        bikeOfferingId <- submit offerer do
            exercise bikeOrgId Offer with
                party = offerer
                fee = 10.0
                bikeId = "MYBIKEID"
        
        -- a committee member can approve the offering:
        bikeOfferingId <- submit committeeOwner do
            exercise bikeOfferingId Approve with
                approver = committeeOwner

        -- Offerer can not approve its own offer
        submitMustFail offerer do
            org <- fetch bikeOrgId
            exercise bikeOfferingId Approve with
                approver = offerer

        -- bike owner can approve only once
        submitMustFail committeeOwner do
            exercise bikeOfferingId Approve with
                approver = committeeOwner

        bikeOfferingId <- submit bikeOwner1 do
            exercise bikeOfferingId Approve with
                approver = bikeOwner1

        bikeOrgId <- submit committeeOwner do
            exercise bikeOrgId AddMember with
                newMember = bikeOwner3

        (bikeTokenId,bikeOrgId)<-submit bikeOwner2 do
            org <- fetch bikeOrgId
            exercise bikeOfferingId FinalApprove with
                approver = bikeOwner2
        
        submit offerer do
            isOwner <- partyIsBikeOwner offerer "BME Bikeorg" committeeOwner
            assertMsg 
                "bofferer has to be a member of the org (aca a bike owner)" 
                (isOwner)

    
test_register_bike = scenario
    do
        -- create org and members
        bme <- getParty "BME Bike sharing"
        bowner1 <- getParty "Bike Owner1"
        bowner2 <- getParty "Bike Owner2"
        bowner3 <- getParty "Bike Owner3"
        bofferer <- getParty "Bike offerer"

        bmeOrgCid <- submit bme do
            create BikeOrg with
                owner = bme
                members = [bowner1,bowner2,bowner3]
                observers = [bofferer]
                name = "BME Bike Sharing org"
                bikeIds = []
        -- register to the bikeOrg
        registrationCid <- submit bofferer do
            create BikeAccountRegistration with
                party = bofferer
                username = "Bike Offerer"
                orgName = "BME Bike Sharing org"
                orgOwner = bme
        
        (bikeAccountCid,bmeOrgCid)<-submit bme do
            exercise registrationCid AcceptRegistration with
                approver = bme
            
        -- create a bike offer - fee = 500.0
        bikeOfferCid <- submit bofferer do
            exercise bmeOrgCid Offer with
                party = bofferer
                fee = 500.0
                bikeId = "MYLITTLEBIKE1"
        {-- approve bike offering --}
        -- owner can not approve
        submitMustFail bofferer do
            exercise bikeOfferCid Approve with
                approver = bofferer
        -- Bike owner (member of the bike org can approve)
        bikeOfferCid <- submit bowner1 do
            exercise bikeOfferCid Approve with
                approver = bowner1
        -- Bike owner can not approve in the name of another bike owner
        submitMustFail bowner1 do
            exercise bikeOfferCid Approve with
                approver = bowner2
        -- Bike owner can not approve the same offer twice
        submitMustFail bowner1 do
            exercise bikeOfferCid Approve with
                approver = bowner1
        -- Second member can not final approve but can approve
        submitMustFail bowner2 do
            exercise bikeOfferCid FinalApprove with
                approver = bowner2

        bikeOfferCid <- submit bowner2 do
            exercise bikeOfferCid Approve with
                approver = bowner2
        -- third member can not approve, only final approve
        submitMustFail bowner3 do
            exercise bikeOfferCid Approve with
                approver = bowner3

        submit bowner3 do
            exercise bikeOfferCid FinalApprove with
                approver = bowner3

        submit bofferer do
            isBikeOwner <- partyIsBikeOwner bofferer "BME Bike Sharing org" bme
            assertMsg "Bofferer has to be a bike owner" (isBikeOwner)
        {-- end approve bike offering test --}

test_handleBikeUsageTransfer_function = scenario -- Tests nothing
    do
        -- create org
        bme <- getParty "BME Bike sharing"
        bowner1 <- getParty "Bike Owner1"
        bnotOwner1 <- getParty "Not BikeOwner1"
        bowner2 <- getParty "Bike Owner2"
        bnotOwner2 <- getParty "Not BikeOwner2"


        bmeOrgCid <- submit bme do
            create BikeOrg with
                owner = bme
                members = [bowner1,bme,bowner2]
                observers = [bnotOwner1,bnotOwner2]
                name = "BME Bike Sharing org"
                bikeIds = []
        
        -- create BikeUsageRight
        bikeUsageRightCid <- submit bme do
            time <- getTime
            org <- fetch bmeOrgCid
            create BikeUsageRight with
                owner = bme
                bikeId = "RANDOM"
                locked = False
                holder = bme
                from = time
                to = time
                fee = 500.0
                bikeCoin =  0.0
                approvedBy= [bowner1]
                orgName = "BME Bike Sharing org"
                orgOwner = bme
                observers = org.members ++ org.observers
        -- create BikeAccounts
        (bmeAccountCid ,bowner1AccountCid,bnotOwner1AccountCid,bowner2AccountCid,bnotOwner2AccountCid)<- submit bme do -- tegyuk fel, hogy most a bme hozta letre az accountokat
            bmeAccountCid<-create BikeAccount with 
                owner = bme
                balance = 1500.0
                name = "bme"
                issuer = bme
                isBikeOwner = False
                bikeOrgName = "BME Bike Sharing org"
            bowner1AccountCid<-create BikeAccount with 
                owner = bowner1
                balance = 1500.0
                name = "bowner1"
                issuer = bme
                isBikeOwner = False
                bikeOrgName = "BME Bike Sharing org"
            bnotOwner1AccountCid<-create BikeAccount with 
                owner = bnotOwner1
                balance = 1500.0
                name = "bnotOwner"
                issuer = bme
                isBikeOwner = False
                bikeOrgName = "BME Bike Sharing org"
            bowner2AccountCid<-create BikeAccount with 
                owner = bowner2
                balance = 1500.0
                name = "bowner1"
                issuer = bme
                isBikeOwner = False
                bikeOrgName = "BME Bike Sharing org"
            bnotOwner2AccountCid<-create BikeAccount with 
                owner = bnotOwner2
                balance = 1500.0
                name = "bnotOwner"
                issuer = bme
                isBikeOwner = False
                bikeOrgName = "BME Bike Sharing org"
            return (bmeAccountCid ,bowner1AccountCid,bnotOwner1AccountCid,bowner2AccountCid,bnotOwner2AccountCid)

        assertMsg "Hello" (True)
test_instanttranfer_bikeusageright = scenario do
    bme <- getParty "BME Bike sharing"
    bowner1 <- getParty "Bike Owner1"
    bowner2 <- getParty "Bike Owner2"
    bowner3 <- getParty "Bike Owner3"
    bnotOwner <- getParty "Bike offerer"

    bmeOrgCid <- submit bme do
        create BikeOrg with
            owner = bme
            members = [bowner1,bowner2,bowner3]
            observers = [bnotOwner]
            name = "BME Bike Sharing org"
            bikeIds = []

    bikeUsageRightCid <- submit bme do
        time <- getTime
        org <- fetch bmeOrgCid
        create BikeUsageRight with
            owner = bme
            bikeId = "RANDOM"
            locked = False
            holder = bme
            from = time
            to = time
            fee = 500.0
            bikeCoin =  0.0
            approvedBy= [bowner2,bowner3,bowner1]
            orgName = "BME Bike Sharing org"
            orgOwner = bme
            observers = org.members ++ org.observers

    --Create Accounts
    (bmeAccountCid ,bowner1AccountCid,bnotOwnerAccountCid)<- submit bme do -- tegyuk fel, hogy most a bme hozta letre az accountokat
        bmeAccountCid<-create BikeAccount with 
            owner = bme
            balance = 1500.0
            name = "bme"
            issuer = bme
            isBikeOwner = False
            bikeOrgName = "BME Bike Sharing org"
        bowner1AccountCid<-create BikeAccount with 
            owner = bowner1
            balance = 1500.0
            name = "bowner1"
            issuer = bme
            isBikeOwner = False
            bikeOrgName = "BME Bike Sharing org"
        bnotOwnerAccountCid<-create BikeAccount with 
            owner = bnotOwner
            balance = 1500.0
            name = "bnotOwner1"
            issuer = bme
            isBikeOwner = False
            bikeOrgName = "BME Bike Sharing org"
        return (bmeAccountCid ,bowner1AccountCid,bnotOwnerAccountCid)

    -- Instant transfer if free (bikeOwner1)
    bikeUsageRightCid <- submit bowner1 do
        (bikeUsageRight,bowner1AccountCid,optionalTokenTransferCid) <- exercise bikeUsageRightCid InstantTransfer with
            party = bowner1
            accountCid = bowner1AccountCid
        -- bowner1 is a bike owner, so it does not need to pay for The InstantTransfer
        account <- fetch bowner1AccountCid
        assertMsg "Bike Owner does not need to pay for instant transfer" (account.balance == 1500.0)
        assertMsg "No token transfer" (optionalTokenTransferCid == None)
        return bikeUsageRight
    -- no instantTransfer if locked less then 3 hours
    submitMustFail bnotOwner do
        exercise bikeUsageRightCid InstantTransfer with
            party = bnotOwner
            accountCid = bnotOwnerAccountCid
    pass (hours 4)
    submit bnotOwner do
        (bikeUsageRightCid,bnotOwnerAccountCid,optionalTokenTransferCid)<-exercise bikeUsageRightCid InstantTransfer with
            party = bnotOwner
            accountCid = bnotOwnerAccountCid
        account <- fetch bnotOwnerAccountCid
        bikeUsageRight <- fetch bikeUsageRightCid
        assertMsg "Non owner must pay" (account.balance == 1500.0 - bikeUsageRight.fee)
        assertMsg "oldHolder is a bike owner so bikeUsageRight bikeCoin wont change" (bikeUsageRight.bikeCoin == 0.0) 
        assertMsg "Token transfer needs to be created" (optionalTokenTransferCid /= None)
        tokenTransfer <- fetch (fromSome optionalTokenTransferCid)
        assertMsg "TokenTransfer needs to be created" (tokenTransfer.to == bowner1 && tokenTransfer.tokens == 500.0)
    assertMsg "Hello" (True)


test_lock_bikeusageright = scenario do
    bme <- getParty "BME Bike sharing"
    bowner1 <- getParty "Bike Owner1"
    bowner2 <- getParty "Bike Owner2"
    bowner3 <- getParty "Bike Owner3"
    bnotOwner <- getParty "Bike offerer"

    bmeOrgCid <- submit bme do
        create BikeOrg with
            owner = bme
            members = [bowner1,bowner2,bowner3,bme]
            observers = [bnotOwner]
            name = "BME Bike Sharing org"
            bikeIds = []

    bikeUsageRightCid <- submit bme do
        time <- getTime
        org <- fetch bmeOrgCid
        create BikeUsageRight with
            owner = bme
            bikeId = "RANDOM"
            locked = False
            holder = bme
            from = time
            to = time
            fee = 500.0
            bikeCoin =  1000.0
            approvedBy= [bowner2,bowner3,bowner1]
            orgName = "BME Bike Sharing org"
            orgOwner = bme
            observers = org.members ++ org.observers

    --Create Accounts
    (bmeAccountCid ,bnotOwnerAccountCid)<- submit bme do -- tegyuk fel, hogy most a bme hozta letre az accountokat
        bmeAccountCid<-create BikeAccount with 
            owner = bme
            balance = 1500.0
            name = "bme"
            issuer = bme
            isBikeOwner = False
            bikeOrgName = "BME Bike Sharing org"
        bnotOwnerAccountCid<-create BikeAccount with 
            owner = bnotOwner
            balance = 1500.0
            name = "bnotOwner1"
            issuer = bme
            isBikeOwner = False
            bikeOrgName = "BME Bike Sharing org"
        return (bmeAccountCid,bnotOwnerAccountCid)

    (bikeUsageRightCid,bnotOwnerAccountCid,optionalTokenTransfer)<-submit bnotOwner do
        exercise bikeUsageRightCid InstantTransfer with
            party = bnotOwner
            accountCid = bnotOwnerAccountCid

    (bikeUsageRightCid,closedBikeUsageCid,oldBikeUsageRight) <- submit bnotOwner do
        oldBikeUsageRight <- fetch bikeUsageRightCid
        (bikeUsageRightCid,closedBikeUsageCid) <- exercise bikeUsageRightCid Lock
        return (bikeUsageRightCid,closedBikeUsageCid,oldBikeUsageRight)
    
    submit bowner1 do
        bikeUsageRight <- fetch bikeUsageRightCid
        closedBikeUsage <- fetch closedBikeUsageCid
        assertMsg 
            "CloseBikeUsageRight bikeCoin has to be the same as in the oldBikeUsageRight"
            (closedBikeUsage.bikeCoin == oldBikeUsageRight.bikeCoin)
        assertMsg "New bike usage right bikeCoin needs to be 0.0" (bikeUsageRight.bikeCoin == 0.0)
        assertMsg "New bike usage right bikeCoin needs to be unlocked" (not bikeUsageRight.locked)

    
    assertMsg "Hello" (True)


test_transfer_bikeusageright = scenario 
    do
        bme <- getParty "BME Bike sharing"
        bowner1 <- getParty "Bike Owner1"
        bowner2 <- getParty "Bike Owner2"
        bowner3 <- getParty "Bike Owner3"
        bofferer <- getParty "Bike offerer"

        bmeOrgCid <- submit bme do
            create BikeOrg with
                owner = bme
                members = [bowner1,bowner2,bowner3]
                observers = [bofferer]
                name = "BME Bike Sharing org"
                bikeIds = []
        
        -- try create a token as bowner1
        submitMustFail bowner1 do
            time <- getTime
            create BikeUsageRight with
                owner = bowner1
                bikeId = "RANDOM"
                locked = False
                holder = bowner1
                from = time
                to = time
                fee = 500.0
                bikeCoin = 100.0
                approvedBy= [bowner2,bowner3,bowner1]
                orgName = "BME Bike Sharing org"
                orgOwner = bme
                observers = [bowner1,bowner2,bowner3]
        -- Org can create ORG BikeTokens
        bikeUsageRight <- submit bme do
            time <- getTime
            org <- fetch bmeOrgCid
            bikeUsageRightCid <- create BikeUsageRight with
                owner = bme
                bikeId = "RANDOM"
                locked = False
                holder = bme
                from = time
                to = time
                fee = 500.0
                bikeCoin = 100.0
                approvedBy= [bowner2,bowner3,bowner1]
                orgName = "BME Bike Sharing org"
                orgOwner = bme
                observers = org.members ++ org.observers
            fetch bikeUsageRightCid
        assertMsg "Token needs to have 100 bikeCoin" (bikeUsageRight.bikeCoin == 100.0)
        {-- Test the token --}

test_make_BikeUsageRequest_and_Accept = scenario 
    do
        bme <- getParty "BME Bike sharing"
        bowner1 <- getParty "Bike Owner1"
        bowner2 <- getParty "Bike Owner2"
        bowner3 <- getParty "Bike Owner3"
        bikerequester1 <- getParty "Bike Requester 1"
        bikerequester2 <- getParty "Bike Requester 2"

        bmeOrgCid <- submit bme do
            create BikeOrg with
                owner = bme
                members = [bowner1,bowner2,bowner3]
                observers = [bikerequester1,bikerequester2]
                name = "BME Bike Sharing org"
                bikeIds = []

        --create a bike account
        bmeAccountCid <- submit bme do -- tegyuk fel, hogy most a bme hozta letre az accountokat
            create BikeAccount with 
                owner = bme
                balance = 1500.0
                name = "account1"
                issuer = bme
                isBikeOwner = False
                bikeOrgName = "BME Bike Sharing org"
        bikerequester1AccountCid <- submit bme do -- itt is, ezért ő az issuer (kb. mintha egy bank lenne)
            create BikeAccount with 
                owner = bikerequester1
                balance = 1500.0
                name = "account2"
                issuer = bme
                isBikeOwner = False
                bikeOrgName = "BME Bike Sharing org"

        bikerequester2AccountCid <- submit bme do -- itt is, ezért ő az issuer (kb. mintha egy bank lenne)
            create BikeAccount with 
                owner = bikerequester2
                balance = 1500.0
                name = "account3"
                issuer = bme
                isBikeOwner = False
                bikeOrgName = "BME Bike Sharing org"
        
        -- create a bike usage right
        time <- getTime 
        let hour = hours 1
        bikeUsageRightCid <- submit bme do 
            create BikeUsageRight with
                owner = bme
                bikeId = "RANDOM"
                locked = False
                holder = bme
                from = time
                to = addRelTime time hour
                fee = 500.0
                bikeCoin = 100.0
                approvedBy= [bowner2,bowner3,bowner1]
                orgName = "BME Bike Sharing org"
                orgOwner = bme
                observers = [bowner1,bowner2,bowner3,bikerequester1,bikerequester2]

        --bikerequester1, who is an observer, makes a bike usage request
        bikeUsageRequestCid <- submit bikerequester1 do
            exercise bikeUsageRightCid MakeUsageRequest with
                requester = bikerequester1
                requesteraccountId = bikerequester1AccountCid
                price = 0.0

        --the first holder of the usage right is bme, who can accept the request
        --accept the bike usage request -> holder of usage right will be the requester
        bikeUsageRightTransferCid <- submit bme do
            exercise bikeUsageRequestCid AcceptRequest

        --bikerequester1 accepts the transfer
        (bikeUsageRightCid,bikerequester1AccountCid,optionalTokenTransfer) <- submit bikerequester1 do
            exercise bikeUsageRightTransferCid AcceptBikeUsageTransfer with
                accountCid = bikerequester1AccountCid

        --current holder of the usage cannot make request
        submitMustFail bikerequester1 do
            exercise bikeUsageRightCid MakeUsageRequest with
                requester = bikerequester1
                requesteraccountId = bikerequester1AccountCid
                price = 150.0

        --then comes bikerequester2, who makes another request for the bike
        bikeUsageRequestCid <- submit bikerequester2 do
            exercise bikeUsageRightCid MakeUsageRequest with 
                requester = bikerequester2
                requesteraccountId = bikerequester2AccountCid
                price = 120.0
            
        -- the second holder of the usage right is bikerequester1
        -- accept the bike usage request -> bikeUsageTransfer will be created
        bikeUsageRightTransferCid <- submit bikerequester1 do
            exercise bikeUsageRequestCid AcceptRequest

        -- bikerequester2 accepts the transfer
        bikeUsageRigthCid <- submit bikerequester2 do
            exercise bikeUsageRightTransferCid AcceptBikeUsageTransfer with
                accountCid = bikerequester2AccountCid

        assertMsg "Hello" (True)
    
test_prolong_bikeUsageRight = scenario do
  -- create bike org + one owner + one non owner
    bme <- getParty "BME Bike sharing"
    bowner1 <- getParty "Bike Owner1"
    bnotOwner <- getParty "Bike offerer"

    bmeOrgCid <- submit bme do
        create BikeOrg with
            owner = bme
            members = [bowner1]
            observers = [bnotOwner]
            name = "BME Bike Sharing org"
            bikeIds = []
    
    -- create BikeUsageRight
    bikeUsageRightCid <- submit bme do
        time <- getTime
        org <- fetch bmeOrgCid
        create BikeUsageRight with
            owner = bme
            bikeId = "RANDOM"
            locked = False
            holder = bme
            from = time
            to = time
            fee = 500.0
            bikeCoin =  0.0
            approvedBy= [bowner1]
            orgName = "BME Bike Sharing org"
            orgOwner = bme
            observers = org.members ++ org.observers
    -- create BikeAccounts
    (bmeAccountCid ,bowner1AccountCid,bnotOwnerAccountCid)<- submit bme do -- tegyuk fel, hogy most a bme hozta letre az accountokat
        bmeAccountCid<-create BikeAccount with 
            owner = bme
            balance = 1500.0
            name = "bme"
            issuer = bme
            isBikeOwner = False
            bikeOrgName = "BME Bike Sharing org"
        bowner1AccountCid<-create BikeAccount with 
            owner = bowner1
            balance = 1500.0
            name = "bowner1"
            issuer = bme
            isBikeOwner = False
            bikeOrgName = "BME Bike Sharing org"
        bnotOwnerAccountCid<-create BikeAccount with 
            owner = bnotOwner
            balance = 1500.0
            name = "bnotOwner"
            issuer = bme
            isBikeOwner = False
            bikeOrgName = "BME Bike Sharing org"
        return (bmeAccountCid ,bowner1AccountCid,bnotOwnerAccountCid)
    -- transfer to bikeOwner
    (bikeUsageRightCid,bowner1AccountCid) <- submit bowner1 do
        (bikeUsageRightCid,bowner1AccountCid,optionalTokenTransfer) <- exercise bikeUsageRightCid InstantTransfer with
            party = bowner1
            accountCid = bowner1AccountCid
        bikeUsageRight <- fetch bikeUsageRightCid
        time <- getTime
        assertMsg "Must be locked til getTime + one hour" (bikeUsageRight.to == (addRelTime  time (hours 1)))
        return (bikeUsageRightCid,bowner1AccountCid)
    -- prolong - no payment!!
    (bikeUsageRightCid,bowner1AccountCid) <- submit bowner1 do
        (bikeUsageRightCid,bowner1AccountCid) <- exercise bikeUsageRightCid ProLongForAnHour with
            accountCid = bowner1AccountCid
        bikeAccount <- fetch bowner1AccountCid
        time <- getTime
        bikeUsageRight <- fetch bikeUsageRightCid
        assertMsg "No payment because he/she is a bikeOwner" (bikeAccount.balance == 1500.0)
        assertMsg "Must be locked til getTime + two hours" (bikeUsageRight.to == (addRelTime  time (hours 2)))
        return (bikeUsageRightCid,bowner1AccountCid)
    -- transfer to non bike owner
    pass (hours (2+3)) -- instant trasfer 3 hours after the expiration of the UsageRight
    (bikeUsageRightCid,bnotOwnerAccountCid) <- submit bnotOwner do
        (bikeUsageRightCid,bnotOwnerAccountCid,optionalTokenTransferd) <- exercise bikeUsageRightCid InstantTransfer with
            party = bnotOwner
            accountCid = bnotOwnerAccountCid
        bikeUsageRight <- fetch bikeUsageRightCid
        time <- getTime
        assertMsg "Must be locked til getTime + one hour" (bikeUsageRight.to == (addRelTime  time (hours 1)))
        return (bikeUsageRightCid,bnotOwnerAccountCid)
    -- prolong - payment
    (bikeUsageRightCid,bnotOwnerAccountCid) <- submit bnotOwner do
        (bikeUsageRightCid,bnotOwnerAccountCid) <- exercise bikeUsageRightCid ProLongForAnHour with
            accountCid = bnotOwnerAccountCid
        bikeAccount <- fetch bnotOwnerAccountCid
        time <- getTime
        bikeUsageRight <- fetch bikeUsageRightCid
        assertMsg "Payment because he/she is not a bikeOwner" (bikeAccount.balance == 500.0)
        assertMsg "Must be locked til getTime + two hours" (bikeUsageRight.to == (addRelTime  time (hours 2)))
        return (bikeUsageRightCid,bnotOwnerAccountCid)

    assertMsg "Hello" (True)

test_one_bikeUsageRight_atOneTime1 = scenario do
    bme <- getParty "BME Bike sharing"
    bowner1 <- getParty "Bike Owner1"
    bnotOwner <- getParty "Bike offerer"

    bmeOrgCid <- submit bme do
        create BikeOrg with
            owner = bme
            members = [bowner1,bme]
            observers = [bnotOwner]
            name = "BME Bike Sharing org"
            bikeIds = []
    
    -- create BikeUsageRight
    (bikeUsageRightCid1,bmeOrgCid) <- submit bme do
        exercise bmeOrgCid CreateBikeUsageRight with
            bikeId = "BIKEID1"
            fee = 200.0
    -- can not create another one with the same BIKEID
    submitMustFail bme do
        exercise bmeOrgCid CreateBikeUsageRight with
            bikeId = "BIKEID1"
            fee = 200.0
    
    (bikeUsageRightCid2,bmeOrgCid) <- submit bme do
        exercise bmeOrgCid CreateBikeUsageRight with
            bikeId = "BIKEID2"
            fee = 200.0

    -- Use it with instant transfer
    (bikeUsageRightCid,bmeAccountCid,optionalTokenTransfer)<-submit bme do
        bmeAccountCid<-create BikeAccount with 
            owner = bme
            balance = 1500.0
            name = "bme"
            issuer = bme
            isBikeOwner = False
            bikeOrgName = "BME Bike Sharing org"
        exercise bikeUsageRightCid1 InstantTransfer with
            party = bme
            accountCid = bmeAccountCid
    -- Try to use another one too
    submitMustFail bme do
        exercise bikeUsageRightCid1 InstantTransfer with
            party = bme
            accountCid = bmeAccountCid

    assertMsg "Hello" (True)

test_one_bikeUsageRight_atOneTime2 = scenario do
    bme <- getParty "BME Bike sharing"
    bowner1 <- getParty "Bike Owner1"
    bnotOwner <- getParty "Bike offerer"

    bmeOrgCid <- submit bme do
        create BikeOrg with
            owner = bme
            members = [bowner1]
            observers = [bnotOwner]
            name = "BME Bike Sharing org"
            bikeIds = []
    
    -- create BikeUsageRight
    bikeUsageRightCid1 <- submit bme do
        time <- getTime
        org <- fetch bmeOrgCid
        create BikeUsageRight with
            owner = bme
            bikeId = "RANDOM1"
            locked = False
            holder = bme
            from = time
            to = time
            fee = 500.0
            bikeCoin =  0.0
            approvedBy= [bowner1]
            orgName = "BME Bike Sharing org"
            orgOwner = bme
            observers = org.members ++ org.observers
    bikeUsageRightCid2 <- submit bme do
        time <- getTime
        org <- fetch bmeOrgCid
        create BikeUsageRight with
            owner = bme
            bikeId = "RANDOM2"
            locked = True
            holder = bme
            from = time
            to = time
            fee = 500.0
            bikeCoin =  0.0
            approvedBy= [bowner1]
            orgName = "BME Bike Sharing org"
            orgOwner = bme
            observers = org.members ++ org.observers
    bikeUsageRightCid1 <- submit bme do
        time <- getTime
        org <- fetch bmeOrgCid
        create BikeUsageRight with
            owner = bme
            bikeId = "RANDOM"
            locked = False
            holder = bme
            from = time
            to = time
            fee = 500.0
            bikeCoin =  0.0
            approvedBy= [bowner1]
            orgName = "BME Bike Sharing org"
            orgOwner = bme
            observers = org.members ++ org.observers
    bikeUsageRightCid2 <- submitMustFail bme do
        time <- getTime
        org <- fetch bmeOrgCid
        create BikeUsageRight with
            owner = bme
            bikeId = "RANDOM"
            locked = True
            holder = bme
            from = time
            to = time
            fee = 500.0
            bikeCoin =  0.0
            approvedBy= [bowner1]
            orgName = "BME Bike Sharing org"
            orgOwner = bme
            observers = org.members ++ org.observers

    assertMsg "Hello" (True)

test_voting_ClosedBikeUsage = scenario do
    bme <- getParty "BME Bike sharing"
    bowner1 <- getParty "Bike Owner1"
    bowner2 <- getParty "Bike Owner2"
    bowner3 <- getParty "Bike Owner3"
    bnotOwner <- getParty "Bike offerer"

    time <- getTime

    bikeUsageRightCid <- submit bme do 
        create BikeUsageRight with
                owner = bme
                bikeId = "RANDOM"
                locked = True
                holder = bme
                from = time
                to = time
                fee = 500.0
                bikeCoin =  0.0
                approvedBy= [bowner2,bowner3,bowner1]
                orgName = "BME Bike Sharing org"
                orgOwner = bme
                observers = [bme,bowner1, bowner2, bowner3, bnotOwner]

    closedBikeUsageCid <- submit bme do 
        create ClosedBikeUsage with
            bikUsageRightCid = bikeUsageRightCid
            bikeCoin = 3000.0
            bikeOwners = [bowner1, bowner2, bowner3]
            bikeOrgOwner = bme
            bikeOrgName = "Bike Org name"
            transferOut = 0
            noTransferOut = 0
            notVotedYet = [bowner1, bowner2, bowner3]
            votersForDivide = []
            numberOfVotedForDivide = 0
            votersForNotDivide = []
            numberOfVotedForNotDivide = 0

    -- not bike owner cannot vote
    submitMustFail bnotOwner do
            exercise closedBikeUsageCid VoteForDivide with
                party = bnotOwner

    -- bike owner can vote
    closedBikeUsageCid <- submit bowner1 do
        exercise closedBikeUsageCid VoteForDivide with 
            party = bowner1

    -- if bike owner has already vote, cannot vote again
    submitMustFail bowner1 do
        exercise closedBikeUsageCid VoteForDivide with 
            party = bowner1

    -- if bike owner has already vote, cannot vote again
    submitMustFail bowner1 do
        exercise closedBikeUsageCid VoteForNotDivide with 
            party = bowner1

    -- another bike owner can vote
    closedBikeUsageCid <- submit bowner2 do
        exercise closedBikeUsageCid VoteForNotDivide with 
            party = bowner2

    -- another bike owner can vote
    closedBikeUsageCid <- submit bowner3 do
        exercise closedBikeUsageCid VoteForNotDivide with 
            party = bowner3

    -- org owner can assess voting
    bikeUsageRightCid <- submit bme do
        exercise closedBikeUsageCid AssessVoting


    assertMsg "Hello" (True)
                 
                

  